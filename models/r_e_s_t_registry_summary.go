// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RESTRegistrySummary r e s t registry summary
//
// swagger:model RESTRegistrySummary
type RESTRegistrySummary struct {

	// auth token
	AuthToken string `json:"auth_token,omitempty"`

	// auth with token
	// Example: true
	// Required: true
	AuthWithToken *bool `json:"auth_with_token"`

	// aws key
	AwsKey *RESTAWSAccountKey `json:"aws_key,omitempty"`

	// cvedb create time
	// Example: 2018-06-20T19:00:53Z
	// Required: true
	// Format: date-time
	CvedbCreateTime *strfmt.DateTime `json:"cvedb_create_time"`

	// cvedb version
	// Example: 1.011
	// Required: true
	CvedbVersion *string `json:"cvedb_version"`

	// error detail
	// Required: true
	ErrorDetail *string `json:"error_detail"`

	// error message
	// Required: true
	ErrorMessage *string `json:"error_message"`

	// failed
	// Example: 1
	// Required: true
	Failed *uint32 `json:"failed"`

	// filters
	// Required: true
	Filters []string `json:"filters"`

	// gcr key
	GcrKey *RESTGCRKey `json:"gcr_key,omitempty"`

	// gitlab external url
	// Required: true
	GitlabExternalURL *string `json:"gitlab_external_url"`

	// gitlab private token
	GitlabPrivateToken string `json:"gitlab_private_token,omitempty"`

	// ibm cloud account
	// Required: true
	IbmCloudAccount *string `json:"ibm_cloud_account"`

	// ibm cloud token url
	// Required: true
	IbmCloudTokenURL *string `json:"ibm_cloud_token_url"`

	// jfrog mode
	// Required: true
	JfrogMode *string `json:"jfrog_mode"`

	// jfrog xray
	JfrogXray *RESTJfrogXray `json:"jfrog_xray,omitempty"`

	// name
	// Example: myregistry
	// Required: true
	Name *string `json:"name"`

	// password
	// Example: mypassword
	// Format: password
	Password strfmt.Password `json:"password,omitempty"`

	// registry
	// Example: https://registry.hub.docker.com/
	// Required: true
	Registry *string `json:"registry"`

	// registry type
	// Example: docker
	// Required: true
	RegistryType *string `json:"registry_type"`

	// repo limit
	// Example: 1
	// Required: true
	RepoLimit *int64 `json:"repo_limit"`

	// rescan after db update
	// Example: false
	// Required: true
	RescanAfterDbUpdate *bool `json:"rescan_after_db_update"`

	// scan layers
	// Example: false
	// Required: true
	ScanLayers *bool `json:"scan_layers"`

	// scanned
	// Example: 12
	// Required: true
	Scanned *uint32 `json:"scanned"`

	// scanning
	// Example: 0
	// Required: true
	Scanning *uint32 `json:"scanning"`

	// schedule
	// Required: true
	Schedule *RESTScanSchedule `json:"schedule"`

	// scheduled
	// Example: 0
	// Required: true
	Scheduled *uint32 `json:"scheduled"`

	// started at
	// Example: 2018-01-18T00:44:02Z
	// Required: true
	// Format: date-time
	StartedAt *strfmt.DateTime `json:"started_at"`

	// status
	// Example: finished
	// Required: true
	Status *string `json:"status"`

	// tag limit
	// Example: 1
	// Required: true
	TagLimit *int64 `json:"tag_limit"`

	// username
	// Example: myusername
	// Required: true
	Username *string `json:"username"`
}

// Validate validates this r e s t registry summary
func (m *RESTRegistrySummary) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthWithToken(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAwsKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvedbCreateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvedbVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrorDetail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrorMessage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGcrKey(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGitlabExternalURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIbmCloudAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIbmCloudTokenURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJfrogMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJfrogXray(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegistry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegistryType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRepoLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRescanAfterDbUpdate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScanLayers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScanned(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScanning(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchedule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScheduled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTagLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsername(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RESTRegistrySummary) validateAuthWithToken(formats strfmt.Registry) error {

	if err := validate.Required("auth_with_token", "body", m.AuthWithToken); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateAwsKey(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsKey) { // not required
		return nil
	}

	if m.AwsKey != nil {
		if err := m.AwsKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aws_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("aws_key")
			}
			return err
		}
	}

	return nil
}

func (m *RESTRegistrySummary) validateCvedbCreateTime(formats strfmt.Registry) error {

	if err := validate.Required("cvedb_create_time", "body", m.CvedbCreateTime); err != nil {
		return err
	}

	if err := validate.FormatOf("cvedb_create_time", "body", "date-time", m.CvedbCreateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateCvedbVersion(formats strfmt.Registry) error {

	if err := validate.Required("cvedb_version", "body", m.CvedbVersion); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateErrorDetail(formats strfmt.Registry) error {

	if err := validate.Required("error_detail", "body", m.ErrorDetail); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateErrorMessage(formats strfmt.Registry) error {

	if err := validate.Required("error_message", "body", m.ErrorMessage); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateFailed(formats strfmt.Registry) error {

	if err := validate.Required("failed", "body", m.Failed); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateFilters(formats strfmt.Registry) error {

	if err := validate.Required("filters", "body", m.Filters); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateGcrKey(formats strfmt.Registry) error {
	if swag.IsZero(m.GcrKey) { // not required
		return nil
	}

	if m.GcrKey != nil {
		if err := m.GcrKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gcr_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("gcr_key")
			}
			return err
		}
	}

	return nil
}

func (m *RESTRegistrySummary) validateGitlabExternalURL(formats strfmt.Registry) error {

	if err := validate.Required("gitlab_external_url", "body", m.GitlabExternalURL); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateIbmCloudAccount(formats strfmt.Registry) error {

	if err := validate.Required("ibm_cloud_account", "body", m.IbmCloudAccount); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateIbmCloudTokenURL(formats strfmt.Registry) error {

	if err := validate.Required("ibm_cloud_token_url", "body", m.IbmCloudTokenURL); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateJfrogMode(formats strfmt.Registry) error {

	if err := validate.Required("jfrog_mode", "body", m.JfrogMode); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateJfrogXray(formats strfmt.Registry) error {
	if swag.IsZero(m.JfrogXray) { // not required
		return nil
	}

	if m.JfrogXray != nil {
		if err := m.JfrogXray.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jfrog_xray")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jfrog_xray")
			}
			return err
		}
	}

	return nil
}

func (m *RESTRegistrySummary) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validatePassword(formats strfmt.Registry) error {
	if swag.IsZero(m.Password) { // not required
		return nil
	}

	if err := validate.FormatOf("password", "body", "password", m.Password.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateRegistry(formats strfmt.Registry) error {

	if err := validate.Required("registry", "body", m.Registry); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateRegistryType(formats strfmt.Registry) error {

	if err := validate.Required("registry_type", "body", m.RegistryType); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateRepoLimit(formats strfmt.Registry) error {

	if err := validate.Required("repo_limit", "body", m.RepoLimit); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateRescanAfterDbUpdate(formats strfmt.Registry) error {

	if err := validate.Required("rescan_after_db_update", "body", m.RescanAfterDbUpdate); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateScanLayers(formats strfmt.Registry) error {

	if err := validate.Required("scan_layers", "body", m.ScanLayers); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateScanned(formats strfmt.Registry) error {

	if err := validate.Required("scanned", "body", m.Scanned); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateScanning(formats strfmt.Registry) error {

	if err := validate.Required("scanning", "body", m.Scanning); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateSchedule(formats strfmt.Registry) error {

	if err := validate.Required("schedule", "body", m.Schedule); err != nil {
		return err
	}

	if m.Schedule != nil {
		if err := m.Schedule.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("schedule")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("schedule")
			}
			return err
		}
	}

	return nil
}

func (m *RESTRegistrySummary) validateScheduled(formats strfmt.Registry) error {

	if err := validate.Required("scheduled", "body", m.Scheduled); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateStartedAt(formats strfmt.Registry) error {

	if err := validate.Required("started_at", "body", m.StartedAt); err != nil {
		return err
	}

	if err := validate.FormatOf("started_at", "body", "date-time", m.StartedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateTagLimit(formats strfmt.Registry) error {

	if err := validate.Required("tag_limit", "body", m.TagLimit); err != nil {
		return err
	}

	return nil
}

func (m *RESTRegistrySummary) validateUsername(formats strfmt.Registry) error {

	if err := validate.Required("username", "body", m.Username); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this r e s t registry summary based on the context it is used
func (m *RESTRegistrySummary) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAwsKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGcrKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJfrogXray(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSchedule(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RESTRegistrySummary) contextValidateAwsKey(ctx context.Context, formats strfmt.Registry) error {

	if m.AwsKey != nil {

		if swag.IsZero(m.AwsKey) { // not required
			return nil
		}

		if err := m.AwsKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("aws_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("aws_key")
			}
			return err
		}
	}

	return nil
}

func (m *RESTRegistrySummary) contextValidateGcrKey(ctx context.Context, formats strfmt.Registry) error {

	if m.GcrKey != nil {

		if swag.IsZero(m.GcrKey) { // not required
			return nil
		}

		if err := m.GcrKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gcr_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("gcr_key")
			}
			return err
		}
	}

	return nil
}

func (m *RESTRegistrySummary) contextValidateJfrogXray(ctx context.Context, formats strfmt.Registry) error {

	if m.JfrogXray != nil {

		if swag.IsZero(m.JfrogXray) { // not required
			return nil
		}

		if err := m.JfrogXray.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("jfrog_xray")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("jfrog_xray")
			}
			return err
		}
	}

	return nil
}

func (m *RESTRegistrySummary) contextValidateSchedule(ctx context.Context, formats strfmt.Registry) error {

	if m.Schedule != nil {

		if err := m.Schedule.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("schedule")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("schedule")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RESTRegistrySummary) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RESTRegistrySummary) UnmarshalBinary(b []byte) error {
	var res RESTRegistrySummary
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
